The files provided in here are INCOMPLETE.  That means they do NOT work properly.  They were fairly close to completion but are NOT COMPLETE and may burn down your servers and get you fired.  These files still have hard-coded paths to Ryan's testing directories.  That said, here is some information about the files in case you want to complete it yourself.  Stream of consciousness, engage!

Here are some thoughts from over a year since the code was last tested.  Unfortunately I can't remember what everything was supposed to do or where I left on things.  I also can't remember why I mounted multiple control group types at a single mount point.  It probably seemed easier at the time and I'm not sure if it was the right decision.

There is a release_agent in the top level cgroup for each controller type, for example: /cgroup/memory/release_agent.  You need a release agent that will cause the cgroup to be removed and the aggregate cgroups usage to be recalculated.  You can have a different file per cgroup type but a common way of handling it is to use a common file then parse $1 (the cgroup path under the cgroup mount point).  I chose to only have one mount point so it behaves a little differently.  There is only one release_agent to work with.  Echo the path of that script to the top level release_agent file.  See create_cgroups.sh.  Another file I was playing with is release_cgroup.sh.  I think that I created a much better, functional verson on a node and forgot to copy the working one back...  Right now it just uses wall to inform you of events.

I can't remember if assign_pid_to_cgroup.c was intended to be setuid or not.  It's been almost a year since I used Torque and I can't recall how the prologue worked even though I used to do a lot of work with it.  Basically, something needs to run as root to create and modify the cgroups.  If you set the cgroup's tasks file to be owned by and writable by the user, the user can assign new pids (enforced by the kernel to be ones that he owns) to his cgroup.  Running as setuid is the only reason I can think of to have assign_pid_to_cgroup.c.  Ideally the task would be broken into two pieces:  1) create/modify/delete cgroups as root and 2) assign new pids to the correct cgroup as the user.

Feel free to ask me (Ryan Cox) questions, though I may not remember how to answer them.
